package dataTools;

##############################################################################

=head1 NAME

C<dataTools>

=head1 VERSION

	$Id: dataTools.pm,v 1.7 2003/02/05 16:55:57 drew Exp $

=begin html

=head1 DO NOT EDIT THIS HTML FILE

This html file is autogenerated from the POD documentation in the 
perl module.  Update that, not this. 

=end html

=head1 SYNOPSIS

	use dataTools;
	
	# Did the user actually enter any data to this appname05?
	my $c
	if ($c = interesting_data(get_data_array_ref())) {
		print "There are $c peices of data that aren't 'no ",
		      "answer' or 'not seen'.\n";
	} else {
		print "Every piece of data is either 'no answer' or ",
		      "'not seen'.\n";
	}
	
	# accessor functions for files
	print 	'appname05 name is\t",	get_appname05_name, "\n",
		'Data file name is\t",	get_data_file_name, "\n",
		'Control dir is\t",	get_control_dir, "\n",
		'Data dir is ',		get_data_dir, "\n",
		'appname05 dir is ',	get_appname05_dir, "\n",
		'SessionID db file is ', get_session_id_db_file, "\n",
		'Blacklist file is ',	get_blacklist_file, "\n";
	
	# store appname05 to .../data/2000/2345foo/2345foo_bar.dat
	write_appname05('_bar');

=head1 DETAILS

This module is B<EXTREEMLY> dependant on C<appname05BIN>'s internal code.
It should probably be moved into C<appname05BIN>, which should probably
provide an API similar to this one.

=cut


##############################################################################
use strict;
use integer;

##############################################################################
use Carp;
use File::Spec::Functions;		# this creates warnings in windows.

use Exporter;
our @ISA        = qw(Exporter);
our @EXPORT     = qw(	interesting_data boring_data 
			get_appname05_name get_data_file_name
			get_control_dir get_data_dir get_appname05_dir 
			get_session_id_db_file get_blacklist_file
			write_appname05);
our @EXPORT_OK  = qw(	interesting_data boring_data get_data_array_ref 
			get_appname05_name get_data_file_name
			get_control_dir get_data_dir get_appname05_dir 
			get_session_id_db_file get_blacklist_file
			write_appname05);
our $VERSION	= '$Revision: 1.7 $';
$VERSION =~ s/^\D*(\S*).*$/$1/o;
sub VERSION { $VERSION }

##############################################################################

=head2 C<boring_data (\@data)>

Return true if data is "Boring" or false if data is not "Boring".

"Boring" means that the data contains no actual input from an end user.
For example if someone just clicks through the entire appname05 without
actually putting anything in.  Why anyone would do this is beyond me, 
but...

=cut

sub boring_data ($) {
	return 0 == interesting_data(shift);
}


##############################################################################

=head2 C<interesting_data (\@data)>

Return the number of "interesting" data points in the response.

Interesting is defined as anything other than a "not seen" or "no answer".
Currently this is not smart enough to identify "auto-populated" data (at 
least beyond the stuff the appname05 engine puts in automatically), so the
programmers will have to take that into account.

=cut
 
sub interesting_data ($) {
	my $dr = shift;
	my $count = 0;

	pop @$dr;			# remove session-id
	pop @$dr;			# remove remote_addr
	for my $e ('date', 'local', 'time') {	# remove each of these
		pop (@$dr) if defined($appname05BIN::form{$e});	
	}

	while ($_ = shift @$dr) {
		last if /^000009$/o;
		$count++ unless /^(\.)|(_)|(9+[89])$/o;
	}
	shift @$dr;			# remove time
	while ($_ = shift @$dr) {
		$count++ unless /^no(t seen)|( answer)$/o;
	}

	return $count;
}


##############################################################################

=head2 C<get_data_array_ref()>

Get the actual data in array form and return a reference to it.

=cut

sub get_data_array_ref () {
	my @data = 
		split 	/$appname05BIN::form{'delimiter'}/,
			&appname05BIN::appname05Results();
	return \@data;
}


##############################################################################

=head2 C<get_appname05_name()>

Get the name of the appname05, ie C<2345foo>.

=cut

sub get_appname05_name () {
	my $tmp = $appname05BIN::form{'appname05'};
	$tmp =~ s/^[^\/]*\/(.*)$/$1/o;		# 2000/(2345foo) -> 2345foo
        return $tmp;
}


##############################################################################

=head2 C<get_data_file_name()>

Get the name of the data file, ie C<2345foo_bar>.

=cut

sub get_data_file_name () {
	my $tmp = $appname05BIN::form{'data'};
	substr ($tmp, -1, 3) = '';		# remove '.dat' from name
	return $tmp;
}


##############################################################################

=head2 C<get_control_dir()>

=head2 C<get_data_dir()>

=head2 C<get_appname05_dir()>

=cut

sub get_control_dir () {
	my $tmp = $appname05BIN::base_page_dir;
	$tmp =~ s/(.*\/)[^\/]*/$1/o;		# (a/b/c/)d -> a/b/c/
	return catdir ($tmp, 'control',	$appname05BIN::form{'appname05'});
}

sub get_data_dir () {
	return catdir ($appname05BIN::base_data_dir, $appname05BIN::form{'appname05'});
}

sub get_appname05_dir () {
	return catdir ($appname05BIN::base_page_dir, $appname05BIN::form{'appname05'});
}


##############################################################################

=head2 C<get_blacklist_file()>

Get the full path and name of the blacklist file, relative to the current
working dirrectory.

=head2 C<get_session_id_db_file()>

Get the full path and name of the session_id db file, relative to the 
current working dirrectory.

See also C<appname05BIN::get_data_file()>

=cut

sub get_blacklist_file () {
	# Should this be in the control dir?
	return catfile (get_appname05_dir(),
			get_appname05_name() . '_blacklist.txt'); 
}

sub get_session_id_db_file () {
	return catfile (get_control_dir(), 
			get_data_file_name() . '_session_id.db');
		
}

##############################################################################

=head2 C<write_appname05 (E<lt>$extensionE<gt>)>

Writes out data line to file.  Ie:

C<../data/2000/2345foo/2345foo${extension}.dat>

=cut

sub write_appname05 {
	my $extension = shift;

	my $orig_submitanswers = $appname05BIN::form{'submitanswers'};
	my $orig_data = $appname05BIN::form{'data'};

	$appname05BIN::form{'submitanswers'} = 1;

	if (defined($extension)) { # add an extension to the name?
		$appname05BIN::form{'data'} =~ s/^(.*)\.dat$/$1${extension}.dat/
			or $appname05BIN::form{'data'} .= $extension;
	} # otherwise go with default name

	my $result = appname05BIN::outputappname05();

	$appname05BIN::form{'submitanswers'} = $orig_submitanswers;
	$appname05BIN::form{'data'} = $orig_data;
	return $result;
}

1;

__END__

=head1 NOTES

I'm using some disgusting namespace violations here.  My appologies to
future maintainers, but I couldn't find a clean way to get this stuff done: 

=over 4

=item *

C<appname05BIN> is B<not> an object so I can't just inherit and extend. 

=item *

I'm afraid to C<use> it since I expect that that would have some
annoying side-effects, and it doesn't export any variables anyway.

=back

So, instead I'm stuck poking my nose into it's namespace via
C<appname05BIN::var> dirrect addressing.  I know how incredibly
unmaintainable and, well, ugly this is.  Such is life.  Ideally 
we'll be moving this functionality into appname05BIN proper in 
the not-to-distant future.

Also, with the move to File::Spec::Functions, the windows implementation
of perl is complaining about soubroutine redefinition when warnings are
enabled.  Of course it works perfectly under unix.

=head1 LOG

	$Log: dataTools.pm,v $
	Revision 1.7  2003/02/05 16:55:57  drew
	added warning to future maintainers -> maintain POD, not html
	
	Revision 1.6  2003/02/05 16:02:43  drew
	documented spurious warnings under windows
	
	Revision 1.5  2003/02/05 15:55:40  drew
	added get_data_file_name() function and use it from other functions.
	added File::Spec::Functions usage.  will provide cross platform file name compatability.  using in all code.
	
	Revision 1.4  2003/02/04 18:33:42  peter
	Changed the seen id database to use the dat file for a name and not the appname05.
	
	Revision 1.3  2002/11/08 20:26:37  drew
	Further documentation work,
	
	Revision 1.2  2002/11/04 20:34:44  drew
	Moved documentation to be more pod conformant (will have documentation for
	functions dirrectly above each function).
	
	Revision 1.1  2002/09/30 14:09:07  drew
	renamed revision to VERSION for mod_perl happiness
	
	Revision 1.0  2002/09/26 18:11:44  drew
	official release version 1.0
	
	Revision 0.9  2002/09/26 14:36:06  drew
	documentation updates and cleaning
	cleaned up some formal params
	
	Revision 0.8  2002/09/24 20:31:16  drew
	tweakage.
	
	Revision 0.7  2002/09/24 20:09:30  drew
	modified writeappname05 to respect form{'data'}.  This will allow us to save output to different places depending on a variable set in the appname05.
	
	also make id section verbatim in POD hdr.
	
	Revision 0.6  2002/09/16 17:55:59  drew
	paramaterized functions
	touched up POD docs.
	
	Revision 0.5  2002/09/11 20:20:03  drew
	testing release...

	Revision 0.4  2002/09/10 20:51:04  drew
	fool appname05 engine into keeping our code.

	Revision 0.3  2002/09/10 16:10:04  drew
	minor format cleanups.
	tweaked VERSION extraction stuff to work correctly.  dho.
	'
	
	Revision 0.2  2002/09/10 14:17:47  drew
	fixed VERSION to reflect CVS revision number.
	
	Revision 0.1  2002/09/09 19:58:21  drew
	factored checkData out of cleanSave.
	moved cleanSave to a dispatch table design to facilitate adding further checks on data and ways to handle states.
	
	Revision 0.0.1.1  2002/09/09 15:36:18  drew
	Initial import.

=head1 AUTHOR

Andrew G. Hammond E<lt>F<mailto:andrew.hammond@appname05site.com>E<gt>

=head1 SEE ALSO

C<appname05BIN.plex>

=head1 COPYRIGHT

Copyright (C) 2002, appname05Site Inc.  All rights reserved.

=cut
